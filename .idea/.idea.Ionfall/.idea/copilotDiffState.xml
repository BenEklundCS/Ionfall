<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Editor/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Editor/CMakeLists.txt" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.20)&#10;project(IonfallEditor)&#10;&#10;# Set C++ standard&#10;set(CMAKE_CXX_STANDARD 17)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;# Add executable&#10;add_executable(IonfallEditor Main.cpp)&#10;&#10;# If you need to link additional libraries, add them here&#10;# target_link_libraries(IonfallEditor library_name)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Scripts/Components/ScrollingBackground.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Scripts/Components/ScrollingBackground.cs" />
              <option name="originalContent" value="using Godot;&#10;using static Godot.GD;&#10;using System;&#10;using Godot.Collections;&#10;&#10;public partial class ScrollingBackground : Node2D {&#10;    // load textures in the editor and assign scroll speeds here&#10;    [Export] public Dictionary&lt;Texture2D, float&gt; Layers = new ();&#10;    // internal state to track offsets for each sprite post-generation&#10;    private Dictionary&lt;Sprite2D, float&gt; _spriteOffsets = new ();&#10;    &#10;    [Export] public CharacterBody2D TrackedPlayer;&#10;&#10;&#10;    public override void _Ready() {&#10;        foreach (var layer in Layers) {&#10;            var sprite = PrepareSprite(layer.Key);&#10;            _spriteOffsets[sprite] = 0f; &#10;            // Add sprite to the scene tree after the current frame to avoid modification during iteration&#10;            Callable.From(() =&gt; {&#10;                GetTree().CurrentScene.AddChild(sprite);&#10;            }).CallDeferred();&#10;        }&#10;    }&#10;&#10;    public override void _Process(double delta) {&#10;        foreach (var spriteEntry in _spriteOffsets.Keys) {&#10;            ProcessSprite(&#10;                spriteEntry, &#10;                spriteEntry.Texture, &#10;                Layers[spriteEntry.Texture], &#10;                (float)delta&#10;            );&#10;        }&#10;    }&#10;    &#10;    private Sprite2D PrepareSprite(Texture2D layer) {&#10;        layer.ResourceName = layer.GetPath().GetFile().GetBaseName();&#10;        &#10;        var sprite = new Sprite2D();&#10;        sprite.Texture = layer;&#10;        &#10;        // Enable region to allow texture offsetting&#10;        sprite.RegionEnabled = true;&#10;        sprite.TextureRepeat = TextureRepeatEnum.Enabled;&#10;        &#10;        var viewportSize = GetViewport().GetVisibleRect().Size;&#10;        // Scale to cover the entire screen&#10;        sprite.Scale = new Vector2(&#10;            viewportSize.X / layer.GetWidth() * 2,&#10;            viewportSize.Y / layer.GetHeight() * 2&#10;        );&#10;        &#10;        // Position at center of screen (sprite's default anchor is center)&#10;        sprite.Position = new Vector2(&#10;            viewportSize.X / 2, &#10;            viewportSize.Y / 2&#10;        );&#10;        sprite.ZIndex = -100;&#10;        &#10;        // Set initial region rect to show the full texture&#10;        sprite.RegionRect = new Rect2(&#10;            0, 0, &#10;            layer.GetWidth(), &#10;            layer.GetHeight()&#10;        );&#10;        &#10;        return sprite;&#10;    }&#10;    &#10;    private void ProcessSprite(Sprite2D sprite, Texture2D texture, float speed, float delta) {&#10;        var newOffsetX = _spriteOffsets[sprite];&#10;        &#10;        // Calculate X movement based on player velocity - move opposite for parallax effect&#10;        if (TrackedPlayer != null &amp;&amp; Mathf.Abs(TrackedPlayer.Velocity.X) &gt; 0) {&#10;            // Subtract for opposite movement and add a small multiplier to reduce intensity&#10;            newOffsetX += TrackedPlayer.Velocity.X * speed * delta * 0.01f;&#10;            var camera = TrackedPlayer.GetNode&lt;Camera2D&gt;(&quot;Camera2D&quot;);&#10;            Position = new Vector2(camera.Position.X, Position.Y);&#10;        }&#10;        &#10;        // Wrap the X offset for seamless scrolling&#10;        newOffsetX = Mathf.PosMod(newOffsetX, texture.GetWidth());&#10;        &#10;        // Update the region rect - show a sliding window of the texture&#10;        sprite.RegionRect = new Rect2(newOffsetX, 0, texture.GetWidth(), texture.GetHeight());&#10;&#10;        _spriteOffsets[sprite] = newOffsetX;&#10;    }&#10;}" />
              <option name="updatedContent" value="using Godot;&#10;using static Godot.GD;&#10;using System;&#10;using Godot.Collections;&#10;&#10;public partial class ScrollingBackground : Node2D {&#10;    // load textures in the editor and assign scroll speeds here&#10;    [Export] public Dictionary&lt;Texture2D, float&gt; Layers = new ();&#10;    // internal state to track offsets for each sprite post-generation&#10;    private Dictionary&lt;Sprite2D, float&gt; _spriteOffsets = new ();&#10;    &#10;    [Export] public CharacterBody2D TrackedPlayer;&#10;&#10;&#10;    public override void _Ready() {&#10;        foreach (var layer in Layers) {&#10;            var sprite = PrepareSprite(layer.Key);&#10;            _spriteOffsets[sprite] = 0f; &#10;            // Add sprite to the scene tree after the current frame to avoid modification during iteration&#10;            Callable.From(() =&gt; {&#10;                GetTree().CurrentScene.AddChild(sprite);&#10;            }).CallDeferred();&#10;        }&#10;    }&#10;&#10;    public override void _Process(double delta) {&#10;        foreach (var spriteEntry in _spriteOffsets.Keys) {&#10;            ProcessSprite(&#10;                spriteEntry, &#10;                spriteEntry.Texture, &#10;                Layers[spriteEntry.Texture], &#10;                (float)delta&#10;            );&#10;        }&#10;    }&#10;    &#10;    private Sprite2D PrepareSprite(Texture2D layer) {&#10;        layer.ResourceName = layer.GetPath().GetFile().GetBaseName();&#10;        &#10;        var sprite = new Sprite2D();&#10;        sprite.Texture = layer;&#10;        &#10;        // Enable region to allow texture offsetting&#10;        sprite.RegionEnabled = true;&#10;        sprite.TextureRepeat = TextureRepeatEnum.Enabled;&#10;        &#10;        var viewportSize = GetViewport().GetVisibleRect().Size;&#10;        // Scale to cover the entire screen&#10;        sprite.Scale = new Vector2(&#10;            viewportSize.X / layer.GetWidth() * 2,&#10;            viewportSize.Y / layer.GetHeight() * 2&#10;        );&#10;        &#10;        // Position at center of screen (sprite's default anchor is center)&#10;        sprite.Position = new Vector2(&#10;            viewportSize.X / 2, &#10;            viewportSize.Y / 2&#10;        );&#10;        sprite.ZIndex = -100;&#10;        &#10;        // Set initial region rect to show the full texture&#10;        sprite.RegionRect = new Rect2(&#10;            0, 0, &#10;            layer.GetWidth(), &#10;            layer.GetHeight()&#10;        );&#10;        &#10;        return sprite;&#10;    }&#10;    &#10;    private void ProcessSprite(Sprite2D sprite, Texture2D texture, float speed, float delta) {&#10;        var newOffsetX = _spriteOffsets[sprite];&#10;        &#10;        // Make the background follow the player's camera position&#10;        if (TrackedPlayer != null) {&#10;            var camera = TrackedPlayer.GetNode&lt;Camera2D&gt;(&quot;Camera2D&quot;);&#10;            // Position the background at the camera's global position&#10;            sprite.GlobalPosition = camera.GlobalPosition;&#10;            &#10;            // Calculate X movement for parallax effect only when moving horizontally&#10;            if (Mathf.Abs(TrackedPlayer.Velocity.X) &gt; 0) {&#10;                // Subtract for opposite movement and add a small multiplier to reduce intensity&#10;                newOffsetX -= TrackedPlayer.Velocity.X * speed * delta * 0.01f;&#10;            }&#10;        }&#10;        &#10;        // Wrap the X offset for seamless scrolling&#10;        newOffsetX = Mathf.PosMod(newOffsetX, texture.GetWidth());&#10;        &#10;        // Update the region rect - show a sliding window of the texture&#10;        sprite.RegionRect = new Rect2(newOffsetX, 0, texture.GetWidth(), texture.GetHeight());&#10;&#10;        _spriteOffsets[sprite] = newOffsetX;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Scripts/Editor/AudioImporter.gd">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Scripts/Editor/AudioImporter.gd" />
              <option name="originalContent" value="@tool&#10;extends EditorScript&#10;&#10;const SOURCE_ROOT := &quot;res://Assets/Audio/Music/&quot;&#10;const OUTPUT_RANDOMIZER := &quot;res://Assets/Audio/Music/MainRandomizer.tres&quot;&#10;const FILENAME_FILTER := &quot;Main&quot;&#10;const STREAM_WEIGHT := 1.0&#10;&#10;func _run() -&gt; void:&#10;&#9;print(&quot;Starting audio import from: %s&quot; % SOURCE_ROOT)&#10;&#9;var matching_paths := _collect_matching_streams(SOURCE_ROOT)&#10;&#9;print(&quot;Found %d matching files&quot; % matching_paths.size())&#10;&#9;&#10;&#9;if matching_paths.is_empty():&#10;&#9;&#9;push_warning(&quot;No matching audio files found under %s&quot; % SOURCE_ROOT)&#10;&#9;&#9;return&#10;&#10;&#9;var randomizer := AudioStreamRandomizer.new()&#10;&#9;var stream_index := 0&#10;&#9;for audio_path in matching_paths:&#10;&#9;&#9;print(&quot;Loading: %s&quot; % audio_path)&#10;&#9;&#9;var stream := ResourceLoader.load(audio_path)&#10;&#9;&#9;if stream == null:&#10;&#9;&#9;&#9;push_warning(&quot;Failed to load %s&quot; % audio_path)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;if not (stream is AudioStream):&#10;&#9;&#9;&#9;push_warning(&quot;Resource at %s is not an AudioStream&quot; % audio_path)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;print(&quot;Successfully loaded stream %d: %s&quot; % [stream_index, audio_path])&#10;&#9;&#9;randomizer.add_stream(stream_index, stream, STREAM_WEIGHT)&#10;&#9;&#9;print(&quot;Added stream %d to randomizer&quot; % stream_index)&#10;&#9;&#9;stream_index += 1&#10;&#10;&#9;print(&quot;Finished adding all streams. Stream index is now: %d&quot; % stream_index)&#10;&#9;&#10;&#9;# Try different ways to check stream count&#10;&#9;var stream_count = stream_index  # Use our own counter as fallback&#10;&#9;if randomizer.has_method(&quot;get_stream_count&quot;):&#10;&#9;&#9;print(&quot;Using get_stream_count() method&quot;)&#10;&#9;&#9;stream_count = randomizer.get_stream_count()&#10;&#9;else:&#10;&#9;&#9;print(&quot;get_stream_count() method not found, using stream_index: %d&quot; % stream_count)&#10;&#9;&#10;&#9;print(&quot;Total streams added: %d&quot; % stream_count)&#10;&#9;&#10;&#9;if stream_count == 0:&#10;&#9;&#9;push_warning(&quot;All matching files failed to load; nothing to save.&quot;)&#10;&#9;&#9;return&#10;&#10;&#9;print(&quot;Attempting to save to: %s&quot; % OUTPUT_RANDOMIZER)&#10;&#9;var save_err := ResourceSaver.save(randomizer, OUTPUT_RANDOMIZER)&#10;&#9;if save_err != OK:&#10;&#9;&#9;push_error(&quot;Failed to save AudioStreamRandomizer to %s (error %d)&quot; % [OUTPUT_RANDOMIZER, save_err])&#10;&#9;&#9;return&#10;&#10;&#9;print(&quot;Saved AudioStreamRandomizer to %s with %d tracks.&quot; % [OUTPUT_RANDOMIZER, stream_count])&#10;&#10;func _collect_matching_streams(root_path: String) -&gt; Array[String]:&#10;&#9;var results: Array[String] = []&#10;&#9;_scan_directory(root_path, results)&#10;&#9;results.sort()&#10;&#9;return results&#10;&#10;func _scan_directory(path: String, accumulator: Array[String]) -&gt; void:&#10;&#9;print(&quot;Scanning directory: %s&quot; % path)&#10;&#9;var dir := DirAccess.open(path)&#10;&#9;if dir == null:&#10;&#9;&#9;push_warning(&quot;Unable to open %s&quot; % path)&#10;&#9;&#9;return&#10;&#10;&#9;dir.list_dir_begin()&#10;&#9;while true:&#10;&#9;&#9;var name := dir.get_next()&#10;&#9;&#9;if name == &quot;&quot;:&#10;&#9;&#9;&#9;break&#10;&#9;&#9;if name == &quot;.&quot; or name == &quot;..&quot;:&#10;&#9;&#9;&#9;continue&#10;&#10;&#9;&#9;var full_path := path.path_join(name)&#10;&#9;&#9;if dir.current_is_dir():&#10;&#9;&#9;&#9;print(&quot;Found subdirectory: %s&quot; % full_path)&#10;&#9;&#9;&#9;_scan_directory(full_path, accumulator)&#10;&#9;&#9;&#9;continue&#10;&#10;&#9;&#9;var lower_name := name.to_lower()&#10;&#9;&#9;# Support multiple audio formats&#10;&#9;&#9;var is_audio_file := lower_name.ends_with(&quot;.mp3&quot;) or lower_name.ends_with(&quot;.ogg&quot;) or lower_name.ends_with(&quot;.wav&quot;)&#10;&#9;&#9;var has_filter := lower_name.find(FILENAME_FILTER.to_lower()) != -1&#10;&#9;&#9;&#10;&#9;&#9;print(&quot;Checking file: %s (is_audio: %s, has_filter: %s)&quot; % [name, is_audio_file, has_filter])&#10;&#9;&#9;&#10;&#9;&#9;if is_audio_file and has_filter:&#10;&#9;&#9;&#9;print(&quot;Adding matching file: %s&quot; % full_path)&#10;&#9;&#9;&#9;accumulator.append(full_path)&#10;&#10;&#9;dir.list_dir_end()&#10;" />
              <option name="updatedContent" value="@tool&#10;extends EditorScript&#10;&#10;const SOURCE_ROOT := &quot;res://Assets/Audio/Music/&quot;&#10;const OUTPUT_RANDOMIZER := &quot;res://Assets/Audio/Music/MainRandomizer.tres&quot;&#10;const FILENAME_FILTER := &quot;Main&quot;&#10;const STREAM_WEIGHT := 1.0&#10;&#10;func _run() -&gt; void:&#10;&#9;var matching_paths := _collect_matching_streams(SOURCE_ROOT)&#10;&#9;&#10;&#9;if matching_paths.is_empty():&#10;&#9;&#9;push_warning(&quot;No matching audio files found under %s&quot; % SOURCE_ROOT)&#10;&#9;&#9;return&#10;&#10;&#9;var randomizer := AudioStreamRandomizer.new()&#10;&#9;var stream_index := 0&#10;&#9;&#10;&#9;for audio_path in matching_paths:&#10;&#9;&#9;var stream := ResourceLoader.load(audio_path)&#10;&#9;&#9;if stream == null or not (stream is AudioStream):&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;randomizer.add_stream(stream_index, stream, STREAM_WEIGHT)&#10;&#9;&#9;stream_index += 1&#10;&#10;&#9;if stream_index == 0:&#10;&#9;&#9;push_warning(&quot;All matching files failed to load; nothing to save.&quot;)&#10;&#9;&#9;return&#10;&#10;&#9;var save_err := ResourceSaver.save(randomizer, OUTPUT_RANDOMIZER)&#10;&#9;if save_err != OK:&#10;&#9;&#9;push_error(&quot;Failed to save AudioStreamRandomizer to %s (error %d)&quot; % [OUTPUT_RANDOMIZER, save_err])&#10;&#9;&#9;return&#10;&#10;&#9;print(&quot;Saved AudioStreamRandomizer to %s with %d tracks.&quot; % [OUTPUT_RANDOMIZER, stream_index])&#10;&#10;func _collect_matching_streams(root_path: String) -&gt; Array[String]:&#10;&#9;var results: Array[String] = []&#10;&#9;_scan_directory(root_path, results)&#10;&#9;results.sort()&#10;&#9;return results&#10;&#10;func _scan_directory(path: String, accumulator: Array[String]) -&gt; void:&#10;&#9;var dir := DirAccess.open(path)&#10;&#9;if dir == null:&#10;&#9;&#9;return&#10;&#10;&#9;dir.list_dir_begin()&#10;&#9;while true:&#10;&#9;&#9;var name := dir.get_next()&#10;&#9;&#9;if name == &quot;&quot;:&#10;&#9;&#9;&#9;break&#10;&#9;&#9;if name == &quot;.&quot; or name == &quot;..&quot;:&#10;&#9;&#9;&#9;continue&#10;&#10;&#9;&#9;var full_path := path.path_join(name)&#10;&#9;&#9;if dir.current_is_dir():&#10;&#9;&#9;&#9;_scan_directory(full_path, accumulator)&#10;&#9;&#9;&#9;continue&#10;&#10;&#9;&#9;var lower_name := name.to_lower()&#10;&#9;&#9;var is_audio_file := lower_name.ends_with(&quot;.mp3&quot;) or lower_name.ends_with(&quot;.ogg&quot;) or lower_name.ends_with(&quot;.wav&quot;)&#10;&#9;&#9;var has_filter := lower_name.find(FILENAME_FILTER.to_lower()) != -1&#10;&#9;&#9;&#10;&#9;&#9;if is_audio_file and has_filter:&#10;&#9;&#9;&#9;accumulator.append(full_path)&#10;&#10;&#9;dir.list_dir_end()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Scripts/Entities/Player.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Scripts/Entities/Player.cs" />
              <option name="originalContent" value="using System.Reflection.Metadata;&#10;using Ionfall.Scripts.Components;&#10;using Ionfall.Scripts.Interfaces;&#10;using Ionfall.Scripts.Objects;&#10;using Ionfall.Scripts.Resources;&#10;using Ionfall.Scripts.UI;&#10;&#10;namespace Ionfall.Scripts.Entities;&#10;&#10;using Godot;&#10;using static Godot.GD;&#10;using System;&#10;&#10;public partial class Player : Ally, IControllable, ISpawnable {&#10;&#9;&#10;&#9;// exports&#10;&#9;[Export] public int JumpForce = 500;&#10;&#9;&#10;&#9;// components&#10;&#9;private AnimatedSprite2D _sprite;&#10;&#9;private Hud _hud;&#10;&#9;private const int Frames = 48;&#10;&#9;private int _directionIndex = 0;&#10;&#9;private Vector2 _crouchOffset = new (0, 15);&#10;&#10;&#9;public override void _Ready() {&#10;&#9;   _sprite = GetNode&lt;AnimatedSprite2D&gt;(&quot;AnimatedSprite2D&quot;);&#10;&#9;   _hud = GetNode&lt;Hud&gt;(&quot;Hud&quot;);&#10;&#9;   base._Ready();&#10;&#9;}&#10;&#9;&#10;&#9;public override void _PhysicsProcess(double delta) {&#10;&#9;&#9;_directionIndex = FindFrameByMouseAngle();&#10;&#9;&#9;_hud.Data = new GameData(0, Health, Gun.Magazine, Gun.Ammo); &#10;&#9;&#9;base._PhysicsProcess(delta);&#10;&#9;}&#10;&#10;&#9;public void Left() {&#10;&#9;&#9;Run(Globals.GameDirection.L);&#10;&#9;}&#10;&#10;&#9;public void Right() {&#10;&#9;&#9;Run(Globals.GameDirection.R);&#10;&#9;}&#10;&#9;&#10;&#9;public void ReleasedMove() {&#10;&#9;&#9;Velocity = new Vector2(0, Velocity.Y);&#10;&#9;&#9;if (!_sprite.Animation.ToString().Contains(&quot;run&quot;)) return;&#10;&#9;&#9;_sprite.Animation = &quot;idle&quot;;&#10;&#9;&#9;_sprite.Stop();&#10;&#9;}&#10;&#10;&#9;public void Jump() {&#10;&#9;&#9;if (!IsOnFloor()) return;&#10;&#9;&#9;Velocity = new Vector2(Velocity.X, -JumpForce);&#10;&#9;}&#10;&#10;&#9;public void Shoot() {&#10;&#9;&#9;Gun.BulletSpawnOffset = (_sprite.Animation == &quot;crouch&quot;) &#10;&#9;&#9;&#9;? _crouchOffset &#10;&#9;&#9;&#9;: Vector2.Zero;&#10;&#9;&#9;Gun.Shoot(GetMouseDirection());&#10;&#9;}&#10;&#10;&#9;public void Crouch() {&#10;&#9;   _sprite.Play(_sprite.Animation == &quot;crouch&quot; ? &quot;idle&quot; : &quot;crouch&quot;);&#10;&#9;}&#10;&#10;&#9;public Node2D Spawn() {&#10;&#9;&#9;return (Node2D)Load&lt;PackedScene&gt;(&quot;res://Scenes/Entities/player.tscn&quot;).Instantiate();&#10;&#9;}&#10;&#9;&#10;&#9;private void Run(Globals.GameDirection direction) {&#10;&#9;&#9;LastDirection = direction;&#10;&#9;&#9;var speed = direction == Globals.GameDirection.R ? Speed : -Speed;&#10;&#9;&#9;Velocity = new Vector2(speed, Velocity.Y);&#10;&#9;&#9;&#10;&#9;&#9;if (_sprite.Animation.ToString().Contains(&quot;run&quot;)) return;&#10;&#9;&#9;&#10;&#9;&#9;_sprite.Animation = $&quot;run_{FindFrameByMouseAngle()}&quot;;&#10;&#9;&#9;_sprite.Play();&#10;&#9;}&#10;&#9;&#10;&#9;protected override void HandleAnimation()&#10;&#9;{&#10;&#9;&#9;if (_sprite.Animation.ToString().Contains(&quot;run&quot;)) {&#10;&#9;&#9;&#9;HandleRunAnimation(_directionIndex);&#10;&#9;&#9;}&#10;&#9;&#9;else {&#10;&#9;&#9;&#9;HandleCrouchOrIdleAnimation(_directionIndex);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;private void HandleRunAnimation(int directionIndex) {&#10;&#9;&#9;var run = $&quot;run_{directionIndex}&quot;;&#10;&#9;&#9;if (_sprite.Animation != run) {&#10;&#9;&#9;&#9;var oldFrame = _sprite.Frame;&#10;&#9;&#9;&#9;var oldProgress = _sprite.FrameProgress;&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;_sprite.Animation = run;&#10;&#9;&#9;&#9;_sprite.Play(); &#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;_sprite.Frame = oldFrame;&#10;&#9;&#9;&#9;_sprite.FrameProgress = oldProgress;&#10;&#10;&#9;&#9;}&#10;&#9;&#9;else {&#10;&#9;&#9;&#9;if (!_sprite.IsPlaying()) _sprite.Play();&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;private void HandleCrouchOrIdleAnimation(int directionIndex)&#10;&#9;{&#10;&#9;&#9;var pose = _sprite.Animation == &quot;crouch&quot; ? &quot;crouch&quot; : &quot;idle&quot;;&#10;&#9;&#9;if (_sprite.Animation != pose)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_sprite.Animation = pose;&#10;&#9;&#9;&#9;_sprite.Stop();&#10;&#9;&#9;}&#10;&#9;&#9;_sprite.Frame = directionIndex;&#10;&#9;}&#10;&#9;&#10;&#9;private int FindFrameByMouseAngle() {&#10;&#9;&#9;var dir = GetMouseDirection();&#10;&#9;&#9;// Flip angle direction&#10;&#9;&#9;var angle = -Mathf.RadToDeg(dir.Angle());&#10;&#9;&#9;// Map (-180,180) → (0,360)&#10;&#9;&#9;if (angle &lt; 0) angle += 360;&#10;&#9;&#9;// 48 frames in the circle → 7.5° per frame&#10;&#9;&#9;var frame = (int)Math.Round(angle / (360.0f / Frames)) % Frames;&#10;&#9;   &#10;&#9;&#9;if (_sprite.FlipH)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;frame = ((Frames/2) - frame) % Frames;&#10;&#9;&#9;&#9;if (frame &lt; 0) frame += Frames;&#10;&#9;&#9;}&#10;&#9;   &#10;&#9;&#9;return frame;&#10;&#9;}&#10;&#9;&#10;&#9;private Vector2 GetMouseDirection() {&#10;&#9;&#9;var mousePosition = GetGlobalMousePosition();&#10;&#9;&#9;return (mousePosition - GlobalPosition).Normalized();&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="using System.Reflection.Metadata;&#10;using Ionfall.Scripts.Components;&#10;using Ionfall.Scripts.Interfaces;&#10;using Ionfall.Scripts.Objects;&#10;using Ionfall.Scripts.Resources;&#10;using Ionfall.Scripts.UI;&#10;&#10;namespace Ionfall.Scripts.Entities;&#10;&#10;using Godot;&#10;using static Godot.GD;&#10;using System;&#10;&#10;public partial class Player : Ally, IControllable, ISpawnable {&#10;&#9;&#10;&#9;// exports&#10;&#9;[Export] public int JumpForce = 500;&#10;&#9;&#10;&#9;// components&#10;&#9;private AnimatedSprite2D _sprite;&#10;&#9;private Hud _hud;&#10;&#9;private const int Frames = 48;&#10;&#9;private int _directionIndex = 0;&#10;&#9;private Vector2 _crouchOffset = new (0, 15);&#10;&#10;&#9;public override void _Ready() {&#10;&#9;   _sprite = GetNode&lt;AnimatedSprite2D&gt;(&quot;AnimatedSprite2D&quot;);&#10;&#9;   _hud = GetNode&lt;Hud&gt;(&quot;Hud&quot;);&#10;&#9;   base._Ready();&#10;&#9;}&#10;&#9;&#10;&#9;public override void _PhysicsProcess(double delta) {&#10;&#9;&#9;_directionIndex = FindFrameByMouseAngle();&#10;&#9;&#9;_hud.Data = new GameData(0, Health, Gun.Magazine, Gun.Ammo); &#10;&#9;&#9;base._PhysicsProcess(delta);&#10;&#9;}&#10;&#10;&#9;public void Left() {&#10;&#9;&#9;Run(Globals.GameDirection.L);&#10;&#9;}&#10;&#10;&#9;public void Right() {&#10;&#9;&#9;Run(Globals.GameDirection.R);&#10;&#9;}&#10;&#9;&#10;&#9;public void ReleasedMove() {&#10;&#9;&#9;Velocity = new Vector2(0, Velocity.Y);&#10;&#9;&#9;if (!_sprite.Animation.ToString().Contains(&quot;run&quot;)) return;&#10;&#9;&#9;_sprite.Animation = &quot;idle&quot;;&#10;&#9;&#9;_sprite.Stop();&#10;&#9;}&#10;&#10;&#9;public void Jump() {&#10;&#9;&#9;if (!IsOnFloor()) return;&#10;&#9;&#9;Velocity = new Vector2(Velocity.X, -JumpForce);&#10;&#9;}&#10;&#10;&#9;public void Shoot() {&#10;&#9;&#9;Gun.BulletSpawnOffset = (_sprite.Animation == &quot;crouch&quot;) &#10;&#9;&#9;&#9;? _crouchOffset &#10;&#9;&#9;&#9;: Vector2.Zero;&#10;&#9;&#9;Gun.Shoot(GetMouseDirection());&#10;&#9;}&#10;&#10;&#9;public void Crouch() {&#10;&#9;   _sprite.Play(_sprite.Animation == &quot;crouch&quot; ? &quot;idle&quot; : &quot;crouch&quot;);&#10;&#9;}&#10;&#10;&#9;public Node2D Spawn() {&#10;&#9;&#9;return (Node2D)Load&lt;PackedScene&gt;(&quot;res://Scenes/Entities/player.tscn&quot;).Instantiate();&#10;&#9;}&#10;&#9;&#10;&#9;private void Run(Globals.GameDirection direction) {&#10;&#9;&#9;LastDirection = direction;&#10;&#9;&#9;var speed = direction == Globals.GameDirection.R ? Speed : -Speed;&#10;&#9;&#9;Velocity = new Vector2(speed, Velocity.Y);&#10;&#9;&#9;&#10;&#9;&#9;if (_sprite.Animation.ToString().Contains(&quot;run&quot;)) return;&#10;&#9;&#9;&#10;&#9;&#9;_sprite.Animation = $&quot;run_{FindFrameByMouseAngle()}&quot;;&#10;&#9;&#9;_sprite.Play();&#10;&#9;}&#10;&#9;&#10;&#9;protected override void HandleAnimation()&#10;&#9;{&#10;&#9;&#9;if (_sprite.Animation.ToString().Contains(&quot;run&quot;)) {&#10;&#9;&#9;&#9;HandleRunAnimation(_directionIndex);&#10;&#9;&#9;}&#10;&#9;&#9;else {&#10;&#9;&#9;&#9;HandleCrouchOrIdleAnimation(_directionIndex);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;private void HandleRunAnimation(int directionIndex) {&#10;&#9;&#9;var run = $&quot;run_{directionIndex}&quot;;&#10;&#9;&#9;if (_sprite.Animation != run) {&#10;&#9;&#9;&#9;var oldFrame = _sprite.Frame;&#10;&#9;&#9;&#9;var oldProgress = _sprite.FrameProgress;&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;_sprite.Animation = run;&#10;&#9;&#9;&#9;_sprite.Play(); &#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;_sprite.Frame = oldFrame;&#10;&#9;&#9;&#9;_sprite.FrameProgress = oldProgress;&#10;&#10;&#9;&#9;}&#10;&#9;&#9;else {&#10;&#9;&#9;&#9;if (!_sprite.IsPlaying()) _sprite.Play();&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;private void HandleCrouchOrIdleAnimation(int directionIndex)&#10;&#9;{&#10;&#9;&#9;var pose = _sprite.Animation == &quot;crouch&quot; ? &quot;crouch&quot; : &quot;idle&quot;;&#10;&#9;&#9;if (_sprite.Animation != pose)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;_sprite.Animation = pose;&#10;&#9;&#9;&#9;_sprite.Stop();&#10;&#9;&#9;}&#10;&#9;&#9;_sprite.Frame = directionIndex;&#10;&#9;}&#10;    // Always use mouse angle for frame selection, not FlipH&#10;    _sprite.Frame = FindFrameByMouseAngle();&#10;}&#10;&#10;private int FindFrameByMouseAngle() {&#10;    var dir = GetMouseDirection();&#10;    // Flip angle direction&#10;    var angle = -Mathf.RadToDeg(dir.Angle());&#10;    // Map (-180,180) → (0,360)&#10;    if (angle &lt; 0) angle += 360;&#10;    // 48 frames in the circle → 7.5° per frame&#10;    var frame = (int)Math.Round(angle / (360.0f / Frames)) % Frames;&#10;    return frame;&#10;}&#10;&#10;private Vector2 GetMouseDirection() {&#10;    var mousePosition = GetGlobalMousePosition();&#10;    return (mousePosition - GlobalPosition).Normalized();&#10;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>